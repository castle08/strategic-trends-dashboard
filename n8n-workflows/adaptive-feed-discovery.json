{
  "name": "Adaptive Feed Discovery",
  "nodes": [
    {
      "parameters": {
        "triggerTimes": {
          "item": [
            {
              "mode": "custom",
              "cronExpression": "0 2 * * 0"
            }
          ]
        }
      },
      "id": "weekly-discovery-trigger",
      "name": "Weekly Discovery Trigger",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [-400, 300]
    },
    {
      "parameters": {
        "jsCode": "// Load current sources configuration\nconst fs = require('fs');\nconst path = require('path');\n\nconst sourcesPath = path.join(__dirname, '../../config/sources.json');\nlet sourcesConfig;\n\ntry {\n  sourcesConfig = JSON.parse(fs.readFileSync(sourcesPath, 'utf8'));\n  console.log('✅ Loaded sources configuration');\n} catch (error) {\n  console.error('❌ Failed to load sources config:', error.message);\n  return [{\n    json: {\n      error: 'Failed to load sources configuration',\n      details: error.message,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Analyze current feed performance\nconst performanceAnalysis = {\n  totalFeeds: sourcesConfig.sources.length,\n  enabledFeeds: sourcesConfig.sources.filter(s => s.enabled).length,\n  categoryBreakdown: {},\n  underperformingFeeds: [],\n  topPerformingFeeds: [],\n  discoveryNeeded: false\n};\n\n// Group feeds by category and analyze performance\nsourcesConfig.sources.forEach(source => {\n  const category = source.metadata?.category || 'Unknown';\n  if (!performanceAnalysis.categoryBreakdown[category]) {\n    performanceAnalysis.categoryBreakdown[category] = {\n      count: 0,\n      enabled: 0,\n      avgSuccessRate: 0,\n      totalTrendContribution: 0\n    };\n  }\n  \n  performanceAnalysis.categoryBreakdown[category].count++;\n  if (source.enabled) {\n    performanceAnalysis.categoryBreakdown[category].enabled++;\n  }\n  \n  // Analyze performance\n  const perf = source.performance || {};\n  const successRate = perf.successRate || 0;\n  const trendContribution = perf.trendContribution || 0;\n  \n  performanceAnalysis.categoryBreakdown[category].avgSuccessRate += successRate;\n  performanceAnalysis.categoryBreakdown[category].totalTrendContribution += trendContribution;\n  \n  // Identify underperforming feeds\n  if (source.enabled && (successRate < 0.6 || trendContribution < 1)) {\n    performanceAnalysis.underperformingFeeds.push({\n      name: source.name,\n      category: category,\n      successRate: successRate,\n      trendContribution: trendContribution,\n      url: source.url\n    });\n  }\n  \n  // Identify top performing feeds\n  if (source.enabled && successRate > 0.8 && trendContribution > 3) {\n    performanceAnalysis.topPerformingFeeds.push({\n      name: source.name,\n      category: category,\n      successRate: successRate,\n      trendContribution: trendContribution,\n      url: source.url\n    });\n  }\n});\n\n// Calculate averages\nObject.keys(performanceAnalysis.categoryBreakdown).forEach(category => {\n  const cat = performanceAnalysis.categoryBreakdown[category];\n  if (cat.enabled > 0) {\n    cat.avgSuccessRate = cat.avgSuccessRate / cat.enabled;\n  }\n});\n\n// Determine if discovery is needed\nconst thresholds = sourcesConfig.performanceThresholds || {};\nconst maxFeedsPerCategory = thresholds.maxFeedsPerCategory || 8;\n\nObject.keys(performanceAnalysis.categoryBreakdown).forEach(category => {\n  const cat = performanceAnalysis.categoryBreakdown[category];\n  if (cat.enabled < Math.min(3, maxFeedsPerCategory) || cat.avgSuccessRate < 0.7) {\n    performanceAnalysis.discoveryNeeded = true;\n  }\n});\n\nconsole.log('📊 Performance Analysis:', JSON.stringify(performanceAnalysis, null, 2));\n\nreturn [{\n  json: {\n    sourcesConfig: sourcesConfig,\n    performanceAnalysis: performanceAnalysis,\n    discoveryKeywords: sourcesConfig.adaptiveDiscovery?.searchKeywords || [],\n    excludedDomains: sourcesConfig.adaptiveDiscovery?.excludedDomains || [],\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "analyze-current-feeds",
      "name": "Analyze Current Feeds",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-200, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "discovery-needed",
              "leftValue": "={{ $json.performanceAnalysis.discoveryNeeded }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "discovery-decision",
      "name": "Discovery Decision",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [0, 300]
    },
    {
      "parameters": {
        "jsCode": "// Generate search queries for new RSS feeds\nconst analysis = $('Analyze Current Feeds').first().json.performanceAnalysis;\nconst keywords = $('Analyze Current Feeds').first().json.discoveryKeywords;\nconst excludedDomains = $('Analyze Current Feeds').first().json.excludedDomains;\n\n// Identify categories that need more feeds\nconst categoriesNeedingFeeds = [];\nObject.entries(analysis.categoryBreakdown).forEach(([category, stats]) => {\n  if (stats.enabled < 3 || stats.avgSuccessRate < 0.7) {\n    categoriesNeedingFeeds.push({\n      category: category,\n      currentFeeds: stats.enabled,\n      avgSuccessRate: stats.avgSuccessRate,\n      priority: stats.enabled < 2 ? 'high' : 'medium'\n    });\n  }\n});\n\n// Generate targeted search queries\nconst searchQueries = [];\n\n// Category-specific searches\ncategoriesNeedingFeeds.forEach(cat => {\n  const categoryKeywords = {\n    'Technology': ['tech', 'technology', 'innovation', 'startup', 'AI', 'artificial intelligence'],\n    'Business': ['business', 'entrepreneur', 'startup', 'finance', 'investment'],\n    'Marketing': ['marketing', 'advertising', 'brand', 'campaign', 'digital marketing'],\n    'Creative': ['creative', 'design', 'art', 'branding', 'visual'],\n    'Advertising': ['advertising', 'ad', 'campaign', 'media', 'creative'],\n    'Healthcare': ['healthcare', 'medical', 'health', 'biotech', 'pharma'],\n    'Finance': ['finance', 'fintech', 'banking', 'investment', 'crypto'],\n    'Retail': ['retail', 'ecommerce', 'shopping', 'consumer', 'commerce'],\n    'Automotive': ['automotive', 'car', 'vehicle', 'transportation', 'mobility'],\n    'Gaming': ['gaming', 'game', 'esports', 'entertainment', 'interactive']\n  };\n  \n  const relevantKeywords = categoryKeywords[cat.category] || [cat.category.toLowerCase()];\n  \n  relevantKeywords.forEach(keyword => {\n    searchQueries.push({\n      query: `${keyword} trends RSS feed`, \n      category: cat.category,\n      priority: cat.priority\n    });\n    searchQueries.push({\n      query: `${keyword} news RSS feed`, \n      category: cat.category,\n      priority: cat.priority\n    });\n  });\n});\n\n// Add general trend discovery queries\nkeywords.slice(0, 8).forEach(keyword => {\n  searchQueries.push({\n    query: keyword,\n    category: 'General',\n    priority: 'medium'\n  });\n});\n\n// Remove duplicates and limit\nconst uniqueQueries = [];\nconst seen = new Set();\nsearchQueries.forEach(query => {\n  const key = query.query.toLowerCase();\n  if (!seen.has(key)) {\n    seen.add(key);\n    uniqueQueries.push(query);\n  }\n});\n\nconst finalQueries = uniqueQueries.slice(0, 20); // Limit to 20 queries\n\nconsole.log(`🔍 Generated ${finalQueries.length} search queries for ${categoriesNeedingFeeds.length} categories`);\nconsole.log('Categories needing feeds:', categoriesNeedingFeeds.map(c => `${c.category} (${c.currentFeeds} feeds, ${(c.avgSuccessRate * 100).toFixed(1)}% success)`));\n\nreturn [{\n  json: {\n    searchQueries: finalQueries,\n    categoriesNeedingFeeds: categoriesNeedingFeeds,\n    excludedDomains: excludedDomains,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "generate-search-queries",
      "name": "Generate Search Queries",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [200, 200]
    },
    {
      "parameters": {
        "jsCode": "// Simulate web search results for RSS feed discovery\n// In production, this would use OpenAI's web search or similar\nconst searchQueries = $('Generate Search Queries').first().json.searchQueries;\nconst excludedDomains = $('Generate Search Queries').first().json.excludedDomains;\n\n// Simulated search results - in real implementation, this would be web search\nconst simulatedResults = [\n  {\n    query: 'tech trends RSS feed',\n    results: [\n      { title: 'TechCrunch RSS Feed', url: 'https://techcrunch.com/feed/', domain: 'techcrunch.com' },\n      { title: 'The Verge RSS', url: 'https://www.theverge.com/rss/index.xml', domain: 'theverge.com' },\n      { title: 'Wired RSS Feed', url: 'https://www.wired.com/feed/rss', domain: 'wired.com' },\n      { title: 'Ars Technica RSS', url: 'https://feeds.arstechnica.com/arstechnica/index', domain: 'arstechnica.com' }\n    ]\n  },\n  {\n    query: 'business innovation RSS',\n    results: [\n      { title: 'Harvard Business Review RSS', url: 'https://hbr.org/feed', domain: 'hbr.org' },\n      { title: 'MIT Technology Review RSS', url: 'https://www.technologyreview.com/feed/', domain: 'technologyreview.com' },\n      { title: 'Fast Company RSS', url: 'https://www.fastcompany.com/feed', domain: 'fastcompany.com' },\n      { title: 'Inc. Magazine RSS', url: 'https://www.inc.com/rss.xml', domain: 'inc.com' }\n    ]\n  },\n  {\n    query: 'marketing trends RSS',\n    results: [\n      { title: 'Marketing Land RSS', url: 'https://marketingland.com/feed', domain: 'marketingland.com' },\n      { title: 'Search Engine Journal RSS', url: 'https://www.searchenginejournal.com/feed/', domain: 'searchenginejournal.com' },\n      { title: 'Content Marketing Institute RSS', url: 'https://contentmarketinginstitute.com/feed/', domain: 'contentmarketinginstitute.com' },\n      { title: 'Copyblogger RSS', url: 'https://copyblogger.com/feed/', domain: 'copyblogger.com' }\n    ]\n  },\n  {\n    query: 'AI trends RSS',\n    results: [\n      { title: 'AI News RSS', url: 'https://artificialintelligence-news.com/feed/', domain: 'artificialintelligence-news.com' },\n      { title: 'VentureBeat AI RSS', url: 'https://venturebeat.com/category/ai/feed/', domain: 'venturebeat.com' },\n      { title: 'Synced AI RSS', url: 'https://syncedreview.com/feed/', domain: 'syncedreview.com' },\n      { title: 'DeepAI RSS', url: 'https://deepai.org/rss.xml', domain: 'deepai.org' }\n    ]\n  },\n  {\n    query: 'startup news RSS',\n    results: [\n      { title: 'TechCrunch Startups RSS', url: 'https://techcrunch.com/tag/startups/feed/', domain: 'techcrunch.com' },\n      { title: 'VentureBeat RSS', url: 'https://venturebeat.com/feed/', domain: 'venturebeat.com' },\n      { title: 'Startup Grind RSS', url: 'https://www.startupgrind.com/feed/', domain: 'startupgrind.com' },\n      { title: 'AngelList RSS', url: 'https://angel.co/feed', domain: 'angel.co' }\n    ]\n  }\n];\n\n// Filter out excluded domains and create candidate feeds\nconst candidateFeeds = [];\n\nsimulatedResults.forEach(queryResult => {\n  queryResult.results.forEach(result => {\n    // Check if domain is excluded\n    const isExcluded = excludedDomains.some(domain => \n      result.domain.includes(domain.replace('*.', ''))\n    );\n    \n    if (!isExcluded) {\n      candidateFeeds.push({\n        name: result.title,\n        url: result.url,\n        domain: result.domain,\n        discoveredFrom: queryResult.query,\n        category: 'Technology', // Would be determined by AI analysis\n        timestamp: new Date().toISOString()\n      });\n    }\n  });\n});\n\n// Remove duplicates based on domain\nconst uniqueFeeds = [];\nconst seenDomains = new Set();\ncandidateFeeds.forEach(feed => {\n  if (!seenDomains.has(feed.domain)) {\n    seenDomains.add(feed.domain);\n    uniqueFeeds.push(feed);\n  }\n});\n\nconsole.log(`🔍 Discovered ${uniqueFeeds.length} candidate RSS feeds`);\nconsole.log('Candidate feeds:', uniqueFeeds.map(f => `${f.name} (${f.domain})`));\n\nreturn [{\n  json: {\n    candidateFeeds: uniqueFeeds,\n    searchQueries: searchQueries,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "web-search-discovery",
      "name": "Web Search Discovery",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 200]
    },
    {
      "parameters": {
        "jsCode": "// Test candidate RSS feeds for validity and quality\nconst candidateFeeds = $('Web Search Discovery').first().json.candidateFeeds;\nconst currentSources = $('Analyze Current Feeds').first().json.sourcesConfig.sources;\n\n// Simulate RSS feed testing\nconst testResults = [];\n\ncandidateFeeds.forEach(feed => {\n  // Simulate testing each feed\n  const testResult = {\n    feed: feed,\n    isValid: Math.random() > 0.3, // 70% success rate\n    responseTime: Math.random() * 2000 + 500, // 500-2500ms\n    articleCount: Math.floor(Math.random() * 20) + 5, // 5-25 articles\n    lastUpdated: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(), // Within last week\n    quality: Math.random() * 0.5 + 0.5, // 0.5-1.0 quality score\n    category: feed.category || 'Technology'\n  };\n  \n  // Check if feed already exists\n  const alreadyExists = currentSources.some(source => \n    source.url === feed.url || source.metadata?.discoveredAt === feed.timestamp\n  );\n  \n  if (alreadyExists) {\n    testResult.isValid = false;\n    testResult.reason = 'Already exists in sources';\n  }\n  \n  testResults.push(testResult);\n});\n\n// Filter valid feeds and sort by quality\nconst validFeeds = testResults\n  .filter(result => result.isValid)\n  .sort((a, b) => b.quality - a.quality);\n\nconsole.log(`✅ Found ${validFeeds.length} valid RSS feeds out of ${candidateFeeds.length} candidates`);\nconsole.log('Top candidates:', validFeeds.slice(0, 5).map(f => `${f.feed.name} (${f.quality.toFixed(2)} quality)`));\n\nreturn [{\n  json: {\n    testResults: testResults,\n    validFeeds: validFeeds,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "test-candidate-feeds",
      "name": "Test Candidate Feeds",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 200]
    },
    {
      "parameters": {
        "jsCode": "// Update sources configuration with new feeds and performance data\nconst validFeeds = $('Test Candidate Feeds').first().json.validFeeds;\nconst currentConfig = $('Analyze Current Feeds').first().json.sourcesConfig;\nconst performanceAnalysis = $('Analyze Current Feeds').first().json.performanceAnalysis;\n\n// Create new source entries for valid feeds\nconst newSources = validFeeds.slice(0, 5).map(feed => ({\n  name: feed.feed.name,\n  type: 'rss',\n  url: feed.feed.url,\n  enabled: true,\n  requiresAuth: false,\n  performance: {\n    lastChecked: new Date().toISOString(),\n    successRate: 1.0, // Initial success since we just tested it\n    trendContribution: 0,\n    avgArticleQuality: feed.quality,\n    lastSuccessfulFetch: new Date().toISOString(),\n    failureCount: 0,\n    totalFetches: 1\n  },\n  metadata: {\n    category: feed.category,\n    language: 'en',\n    updateFrequency: 'daily',\n    discoveredAt: feed.feed.timestamp,\n    discoveredFrom: feed.feed.discoveredFrom,\n    initialQuality: feed.quality\n  }\n}));\n\n// Update existing sources with performance data\nconst updatedSources = currentConfig.sources.map(source => {\n  // Simulate performance updates for existing sources\n  const updatedPerformance = { ...source.performance };\n  \n  if (source.enabled) {\n    // Simulate some performance improvement/decline\n    const performanceChange = (Math.random() - 0.5) * 0.2; // ±10% change\n    updatedPerformance.successRate = Math.max(0, Math.min(1, (updatedPerformance.successRate || 0.5) + performanceChange));\n    updatedPerformance.trendContribution = Math.max(0, (updatedPerformance.trendContribution || 0) + Math.floor(Math.random() * 3) - 1);\n    updatedPerformance.lastChecked = new Date().toISOString();\n    updatedPerformance.totalFetches = (updatedPerformance.totalFetches || 0) + 1;\n  }\n  \n  return {\n    ...source,\n    performance: updatedPerformance\n  };\n});\n\n// Disable underperforming feeds\nconst thresholds = currentConfig.performanceThresholds || {};\nconst finalSources = updatedSources.map(source => {\n  const perf = source.performance || {};\n  const shouldDisable = source.enabled && (\n    perf.failureCount >= (thresholds.autoDisableAfterFailures || 5) ||\n    perf.successRate < (thresholds.minSuccessRateToKeep || 0.6) ||\n    perf.trendContribution < (thresholds.minTrendContributionToKeep || 1)\n  );\n  \n  if (shouldDisable) {\n    console.log(`🚫 Disabling underperforming feed: ${source.name} (success: ${perf.successRate}, trends: ${perf.trendContribution})`);\n    return { ...source, enabled: false };\n  }\n  \n  return source;\n});\n\n// Add new sources\nconst finalConfig = {\n  ...currentConfig,\n  sources: [...finalSources, ...newSources],\n  adaptiveDiscovery: {\n    ...currentConfig.adaptiveDiscovery,\n    lastDiscoveryRun: new Date().toISOString()\n  }\n};\n\n// Save updated configuration\nconst fs = require('fs');\nconst path = require('path');\nconst configPath = path.join(__dirname, '../../config/sources.json');\n\ntry {\n  fs.writeFileSync(configPath, JSON.stringify(finalConfig, null, 2));\n  console.log('✅ Updated sources configuration saved');\n} catch (error) {\n  console.error('❌ Failed to save updated config:', error.message);\n}\n\nconst summary = {\n  newFeedsAdded: newSources.length,\n  feedsDisabled: finalSources.filter(s => !s.enabled && s.performance?.lastChecked).length,\n  totalFeeds: finalConfig.sources.length,\n  enabledFeeds: finalConfig.sources.filter(s => s.enabled).length,\n  newFeedNames: newSources.map(s => s.name),\n  disabledFeedNames: finalSources.filter(s => !s.enabled && s.performance?.lastChecked).map(s => s.name)\n};\n\nconsole.log('📊 Discovery Summary:', summary);\n\nreturn [{\n  json: {\n    updatedConfig: finalConfig,\n    summary: summary,\n    newFeeds: newSources,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "update-sources-config",
      "name": "Update Sources Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 200]
    },
    {
      "parameters": {
        "jsCode": "// Generate discovery report\nconst summary = $('Update Sources Config').first().json.summary;\nconst performanceAnalysis = $('Analyze Current Feeds').first().json.performanceAnalysis;\n\nconst report = {\n  timestamp: new Date().toISOString(),\n  discoveryRun: true,\n  summary: summary,\n  performance: {\n    totalFeeds: performanceAnalysis.totalFeeds,\n    enabledFeeds: performanceAnalysis.enabledFeeds,\n    underperformingCount: performanceAnalysis.underperformingFeeds.length,\n    topPerformingCount: performanceAnalysis.topPerformingFeeds.length\n  },\n  recommendations: []\n};\n\n// Generate recommendations\nif (summary.newFeedsAdded > 0) {\n  report.recommendations.push(`Added ${summary.newFeedsAdded} new RSS feeds to improve coverage`);\n}\n\nif (summary.feedsDisabled > 0) {\n  report.recommendations.push(`Disabled ${summary.feedsDisabled} underperforming feeds to maintain quality`);\n}\n\nif (performanceAnalysis.underperformingFeeds.length > 0) {\n  report.recommendations.push(`Monitor ${performanceAnalysis.underperformingFeeds.length} feeds that are underperforming`);\n}\n\n// Category-specific recommendations\nObject.entries(performanceAnalysis.categoryBreakdown).forEach(([category, stats]) => {\n  if (stats.enabled < 3) {\n    report.recommendations.push(`Consider adding more feeds to ${category} category (currently ${stats.enabled} feeds)`);\n  }\n  if (stats.avgSuccessRate < 0.7) {\n    report.recommendations.push(`Improve feed quality in ${category} category (${(stats.avgSuccessRate * 100).toFixed(1)}% success rate)`);\n  }\n});\n\nconsole.log('📋 Discovery Report:', JSON.stringify(report, null, 2));\n\nreturn [{\n  json: report\n}];"
      },
      "id": "generate-discovery-report",
      "name": "Generate Discovery Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 200]
    },
    {
      "parameters": {
        "jsCode": "// No discovery needed - generate status report\nconst performanceAnalysis = $('Analyze Current Feeds').first().json.performanceAnalysis;\n\nconst report = {\n  timestamp: new Date().toISOString(),\n  discoveryRun: false,\n  reason: 'No discovery needed - current feeds performing well',\n  performance: {\n    totalFeeds: performanceAnalysis.totalFeeds,\n    enabledFeeds: performanceAnalysis.enabledFeeds,\n    underperformingCount: performanceAnalysis.underperformingFeeds.length,\n    topPerformingCount: performanceAnalysis.topPerformingFeeds.length\n  },\n  topFeeds: performanceAnalysis.topPerformingFeeds.slice(0, 5),\n  underperformingFeeds: performanceAnalysis.underperformingFeeds.slice(0, 5),\n  recommendations: []\n};\n\n// Generate maintenance recommendations\nif (performanceAnalysis.underperformingFeeds.length > 0) {\n  report.recommendations.push(`Monitor ${performanceAnalysis.underperformingFeeds.length} underperforming feeds`);\n}\n\nObject.entries(performanceAnalysis.categoryBreakdown).forEach(([category, stats]) => {\n  if (stats.avgSuccessRate < 0.8) {\n    report.recommendations.push(`Optimize ${category} feeds for better success rate`);\n  }\n});\n\nconsole.log('📋 Status Report:', JSON.stringify(report, null, 2));\n\nreturn [{\n  json: report\n}];"
      },
      "id": "generate-status-report",
      "name": "Generate Status Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 400]
    }
  ],
  "connections": {
    "Weekly Discovery Trigger": {
      "main": [
        [
          {
            "node": "Analyze Current Feeds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Analyze Current Feeds": {
      "main": [
        [
          {
            "node": "Discovery Decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Discovery Decision": {
      "main": [
        [
          {
            "node": "Generate Search Queries",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Status Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Search Queries": {
      "main": [
        [
          {
            "node": "Web Search Discovery",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Web Search Discovery": {
      "main": [
        [
          {
            "node": "Test Candidate Feeds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Test Candidate Feeds": {
      "main": [
        [
          {
            "node": "Update Sources Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Sources Config": {
      "main": [
        [
          {
            "node": "Generate Discovery Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "meta": null,
  "pinData": {},
  "versionId": "adaptive-discovery-v1",
  "triggerCount": 0
}

{
  "name": "test_v5_with_images",
  "nodes": [
    {
      "parameters": {
        "numberInputs": 5
      },
      "id": "068e2628-7c82-4283-a88f-0f9873249071",
      "name": "Merge RSS Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        768,
        592
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process Articles for Strategic Trend Analysis\n\nconst TZ = 'Europe/London';\nconst MIN_TITLE_LEN = 10;\nconst MIN_SUMMARY_LEN = 30;\nconst MAX_ITEMS = 100;\nconst LOOKBACK_DAYS = 7;\n\nconst BRAND_TAGS = ['retail','sportswear','energy drinks'];\nconst REGION = 'UK';\nconst LIMITS = { max_items: 20, min_confidence: 40 };\n\nfunction stripHtml(s='') {\n  return (s || '')\n    .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<[^>]+>/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\nfunction hostFromUrl(u='') { try { return new URL(u).hostname.replace(/^www\\./,''); } catch { return ''; } }\nfunction toISO(d) {\n  if (!d) return null;\n  const tryDates = Array.isArray(d) ? d : [d];\n  for (const raw of tryDates) {\n    const t = raw ? Date.parse(raw) : NaN;\n    if (!Number.isNaN(t)) return new Date(t).toISOString();\n  }\n  return null;\n}\nfunction withinLookback(iso) {\n  if (!iso) return false;\n  const now = new Date();\n  const then = new Date(now); then.setDate(now.getDate() - LOOKBACK_DAYS);\n  return new Date(iso) >= then;\n}\nfunction normTitle(s='') { return s.toLowerCase().replace(/\\s+/g,' ').trim(); }\n\nconst inputItems = $input.all();\n\n// Flatten RSS outputs\nlet raw = [];\nfor (const it of inputItems) {\n  if (Array.isArray(it.json?.items)) raw = raw.concat(it.json.items);\n  else raw.push(it.json);\n}\n\n// Normalize articles for trend analysis\nconst normalised = [];\nfor (const r of raw) {\n  const title = (r.title || r.headline || '').trim();\n  const url = (r.link || r.url || r.guid || '').trim();\n  const summary = stripHtml(r.description || r.contentSnippet || r.summary || r.content || '');\n  const publishedAt = toISO([r.isoDate, r.pubDate, r.published, r.updated, r.date]) || new Date().toISOString();\n  \n  // Simplified source detection for trend context\n  let source = 'Market Intelligence';\n  const host = hostFromUrl(url);\n  if (host.includes('adweek')) source = 'Adweek';\n  else if (host.includes('campaignlive')) source = 'Campaign';\n  else if (host.includes('reddit.com')) source = 'Reddit';\n\n  if (title.length < MIN_TITLE_LEN) continue;\n  if (summary.length < MIN_SUMMARY_LEN) continue;\n  if (!withinLookback(publishedAt)) continue;\n\n  normalised.push({ title, summary, source, publishedAt });\n}\n\n// Dedupe by title similarity\nconst seenTitles = new Set(); const deduped = [];\nfor (const it of normalised) {\n  const key = normTitle(it.title);\n  if (seenTitles.has(key)) continue;\n  seenTitles.add(key);\n  deduped.push(it);\n}\n\n// Sort and limit\ndeduped.sort((a,b) => new Date(b.publishedAt) - new Date(a.publishedAt));\nconst items = deduped.slice(0, MAX_ITEMS);\n\nconsole.log(`ðŸ“Š Processing ${items.length} articles for strategic trend extraction`);\nconsole.log(`ðŸŽ¯ Target: Extract ${LIMITS.max_items} strategic trends for advertising agencies`);\n\n// Create analysis summary for agent\nconst articleSummary = items.map(item => `\"${item.title}\" - ${item.summary.substring(0, 200)}...`).join('\\n\\n');\n\nreturn [{\n  json: {\n    articleSummary,\n    articleCount: items.length,\n    sources: [...new Set(items.map(i => i.source))],\n    brand_tags: BRAND_TAGS,\n    region: REGION,\n    limits: LIMITS\n  }\n}];"
      },
      "id": "004e2c5a-8584-4cd7-8062-b3f44f3e8fb9",
      "name": "Process Articles",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        992,
        640
      ]
    },
    {
      "parameters": {
        "model": "gpt-4o",
        "options": {}
      },
      "id": "503af695-95bc-40bb-92aa-72259f55c7b0",
      "name": "OpenAI Chat Model",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [
        1248,
        864
      ],
      "credentials": {
        "openAiApi": {
          "id": "EJ4bHf6JFSTiAvix",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsonSchema": "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"required\": [\"trends\", \"generatedAt\", \"sourceSummary\"],\n  \"properties\": {\n    \"generatedAt\": { \"type\": \"string\" },\n    \"sourceSummary\": {\n      \"type\": \"object\",\n      \"required\": [\"totalFetched\", \"afterCluster\", \"sources\"],\n      \"properties\": {\n        \"totalFetched\": { \"type\": \"number\" },\n        \"afterCluster\": { \"type\": \"number\" },\n        \"sources\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }\n      }\n    },\n    \"trends\": {\n      \"type\": \"array\",\n      \"minItems\": 10,\n      \"maxItems\": 20,\n      \"items\": {\n        \"type\": \"object\",\n        \"required\": [\"id\", \"title\", \"summary\", \"category\", \"scores\", \"viz\", \"whyItMatters\", \"tags\", \"brandAngles\", \"exampleUseCases\", \"creative\"],\n        \"properties\": {\n          \"id\": { \"type\": \"string\" },\n          \"title\": { \"type\": \"string\" },\n          \"summary\": { \"type\": \"string\" },\n          \"category\": { \"type\": \"string\" },\n          \"tags\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n          \"scores\": {\n            \"type\": \"object\",\n            \"required\": [\"novelty\", \"velocity\", \"relevance\", \"confidence\", \"total\"],\n            \"properties\": {\n              \"novelty\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 100 },\n              \"velocity\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 100 },\n              \"relevance\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 100 },\n              \"confidence\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 100 },\n              \"total\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 100 }\n            }\n          },\n          \"whyItMatters\": { \"type\": \"string\" },\n          \"brandAngles\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n          \"exampleUseCases\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n          \"creative\": {\n            \"type\": \"object\",\n            \"required\": [\"shortCardCopy\", \"imagePrompt\", \"altText\", \"podcastSnippet\"],\n            \"properties\": {\n              \"shortCardCopy\": { \"type\": \"string\", \"maxLength\": 140 },\n              \"imagePrompt\": { \"type\": \"string\"},\n              \"altText\": { \"type\": \"string\" },\n              \"podcastSnippet\": { \"type\": \"string\" }\n            }\n          },\n          \"viz\": {\n            \"type\": \"object\",\n            \"required\": [\"size\", \"intensity\", \"colorHint\"],\n            \"properties\": {\n              \"size\": { \"type\": \"number\" },\n              \"intensity\": { \"type\": \"number\" },\n              \"colorHint\": { \"type\": \"string\" }\n            }\n          }\n        }\n      }\n    }\n  }\n}"
      },
      "id": "31f8d2b4-79aa-444a-88a0-7495ad9d2a56",
      "name": "Structured Output Parser",
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1,
      "position": [
        1376,
        864
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "You are TrendMaker, a strategic trend analyst for advertising agencies. \n\nAnalyze these {{ $json.articleCount }} recent marketing articles and extract strategic trends:\n\n{{ $json.articleSummary }}\n\nYour job is to identify strategic market trends that will help advertising agencies win business and serve clients better. \n\n**Generate exactly 10-15 strategic trends** - not article summaries, but broader market movements and transformations.\n\nEach trend should:\n- Have a strategic trend title (e.g., \"AI-Powered Creative Automation Reaches Mass Adoption\")\n- Focus on industry transformations, not individual company news\n- Help agencies understand where the market is heading\n- Be scored 1-100 on novelty, velocity, relevance, and confidence",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are TrendMaker, a strategic trend analyst. Your job is to identify broader market trends from articles, NOT summarize individual articles.\n\n### CRITICAL: Create Strategic Trends, Not Article Summaries\n- Analyze patterns across articles to identify strategic market movements\n- Create trend titles that capture broader transformations (e.g. \"Privacy-First Marketing Becomes Competitive Advantage\")\n- Focus on what these articles collectively tell us about where the industry is heading\n- Generate insights that help agencies anticipate market changes\n\n### Requirements:\n- Generate EXACTLY 10-15 strategic trends (minimum 10)\n- All scores must be integers 1-100\n- Each trend represents a strategic market movement, not an individual article\n- Trends should help agencies win business and serve clients better\n- No URLs needed - these are strategic insights, not article links\n\n### Scoring (1-100):\n- novelty: How new is this trend vs established practice\n- velocity: How fast is this trend gaining momentum  \n- relevance: How much will this impact advertising agencies\n- confidence: How certain are we this trend is real\n- total: weighted average\n\n### Categories: \nTechnology, Media, Culture, Retail, AI, Consumer Behaviour, Creativity, Regulation, Data & Privacy, Sustainability\n\n### Trend Examples:\n- \"Retail Media Networks Challenge Traditional Display Advertising\"\n- \"Creator Economy Professionalizes Into Enterprise Marketing Channel\"\n- \"AI Content Generation Forces Creative Industry Restructuring\"\n\nReturn ONLY valid JSON matching the schema."
        }
      },
      "id": "91c242cb-09ef-4af5-9c90-3847c5dad73a",
      "name": "Strategic Trend Analyzer",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        1216,
        640
      ]
    },
    {
      "parameters": {
        "jsCode": "// Finalize strategic trends for visualization\n\nconst data = $json;\nconst trends = Array.isArray(data.trends) ? data.trends : [];\n\n// Ensure minimum trend count\nif (trends.length < 10) {\n  throw new Error(`Only ${trends.length} trends generated. Minimum required: 10`);\n}\n\n// Fix sourceSummary structure\nif (!data.sourceSummary || !Array.isArray(data.sourceSummary.sources)) {\n  data.sourceSummary = {\n    totalFetched: trends.length,\n    afterCluster: trends.length,\n    sources: ['Strategic Market Intelligence']\n  };\n}\n\n// Enhanced viz properties for strategic trends\nfor (let i = 0; i < trends.length; i++) {\n  const trend = trends[i];\n  \n  if (trend.scores) {\n    const totalScore = trend.scores.total || 50;\n    const velocity = trend.scores.velocity || 50;\n    const novelty = trend.scores.novelty || 50;\n    \n    // Enhanced size mapping (10-20 for strategic importance)\n    trend.viz = trend.viz || {};\n    trend.viz.size = Math.max(10, Math.min(20, Math.round(10 + (totalScore / 100) * 10)));\n    \n    // Enhanced intensity based on velocity + novelty\n    const intensityScore = (velocity + novelty) / 2;\n    trend.viz.intensity = Number((1.2 + (intensityScore / 100) * 1.8).toFixed(2));\n    \n    // Strategic category colors\n    const cat = (trend.category || 'Technology').toLowerCase();\n    let hue;\n    switch(cat) {\n      case 'technology': case 'ai': hue = 240; break; // Blue\n      case 'media': case 'culture': hue = 300; break; // Purple  \n      case 'retail': case 'consumer behaviour': hue = 120; break; // Green\n      case 'creativity': hue = 60; break; // Yellow\n      case 'regulation': case 'data & privacy': hue = 0; break; // Red\n      case 'sustainability': hue = 150; break; // Teal\n      default: hue = 210; // Default blue\n    }\n    trend.viz.colorHint = `hsl(${hue}, 80%, 50%)`;\n    \n    // Add unique trend ID if missing\n    if (!trend.id) {\n      trend.id = `trend_${i + 1}_${Date.now().toString().slice(-4)}`;\n    }\n  }\n}\n\ndata.generatedAt = data.generatedAt || new Date().toISOString();\n\n// Strategic logging\nconsole.log(`ðŸŽ¯ Generated ${trends.length} strategic trends for agency intelligence`);\nconst scoreRange = trends.map(t => t.scores?.total || 0);\nconst minScore = Math.min(...scoreRange);\nconst maxScore = Math.max(...scoreRange);\nconsole.log(`ðŸ“Š Strategic Impact Range: ${minScore}-${maxScore}`);\nconsole.log(`ðŸ” Categories: ${[...new Set(trends.map(t => t.category))].join(', ')}`);\n\ntrends.slice(0, 5).forEach((trend, i) => {\n  console.log(`${i+1}. \"${trend.title}\" (${trend.category}) - Impact: ${trend.scores?.total}`);\n});\n\nreturn [{ json: data }];"
      },
      "id": "ff627ad9-b80d-47ff-bac9-6aea8bdc6a49",
      "name": "Finalize Trends",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        640
      ]
    },
    {
      "parameters": {
        "jsCode": "// Generate detailed image prompts for each trend using the template from imageprompt.md\n// This node should be inserted between \"Finalize Trends\" and the OpenAI image generation node\n\nconst inputData = $json;\nconst trends = Array.isArray(inputData.trends) ? inputData.trends : [];\n\nconsole.log(`ðŸŽ¨ Generating image prompts for ${trends.length} trends...`);\n\n// Process each trend to create detailed image prompts\nconst processedTrends = trends.map((trend, index) => {\n  const { title, category, creative } = trend;\n  \n  // Use the existing imagePrompt as the base, or create one from the title\n  const basePrompt = creative?.imagePrompt || `A 3D visualization representing \"${title}\"`;\n  \n  // Create the detailed prompt using the template from imageprompt.md\n  const detailedPrompt = `Create a hyper-detailed 3D render of ${basePrompt} symbolizing \"${title}\" (trend title) in the ${category} (trend category) category.\n  \n  â€¢ Perspective: Slightly angled from above, showing depth and dimension.\n  â€¢ Primary color tone: Use colors that complement the ${category} theme prominently in lighting, accents, and key elements.\n  â€¢ Details: Include realistic textures, materials, and lighting that represent the trend concept.\n  â€¢ Symbolism: Incorporate visual metaphors that clearly represent \"${title}\" and its significance in ${category}.\n  â€¢ Lighting: Studio-quality lighting with soft shadows and realistic reflections.\n  â€¢ Style: Realistic yet slightly stylized for visual clarity, cinematic depth of field.\n  â€¢ Background: Transparent PNG with alpha channel (no sky or scenery).\n  â€¢ Format: 1024x1024 PNG with transparent background.`;\n\n  console.log(`ðŸ“ Generated prompt for \"${title}\": ${detailedPrompt.substring(0, 100)}...`);\n  \n  return {\n    ...trend,\n    imageGenerationPrompt: detailedPrompt\n  };\n});\n\nconsole.log(`âœ… Generated ${processedTrends.length} image prompts`);\n\nreturn [{\n  json: {\n    ...inputData,\n    trends: processedTrends\n  }\n}];"
      },
      "id": "1f49d0cc-a19f-4edf-a232-083e111d40d4",
      "name": "Generate Image Prompts",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1840,
        720
      ]
    },
    {
      "parameters": {
        "jsCode": "// Split trends into individual items for image generation\n// This node creates separate items for each trend so the LangChain OpenAI node can process them individually\n\nconst inputData = $json;\nconst trends = Array.isArray(inputData.trends) ? inputData.trends : [];\n\nconsole.log(`ðŸ”„ Splitting ${trends.length} trends into individual items for image generation...`);\n\n// Limit to first 5 trends for testing (to control costs and processing time)\n// In production, you can increase this number or process all trends\nconst MAX_TRENDS_FOR_IMAGES = 5;\nconst trendsToProcess = trends.slice(0, MAX_TRENDS_FOR_IMAGES);\nconsole.log(`ðŸ“Š Processing first ${trendsToProcess.length} trends for image generation (out of ${trends.length} total)`);\n\n// Create separate items for each trend to process\n// For LangChain OpenAI node, we need to structure the data differently\nconst individualTrends = trendsToProcess.map(trend => ({\n  json: {\n    trend: {\n      ...trend,\n      imageGenerationPrompt: trend.imageGenerationPrompt\n    },\n    trendId: trend.id,\n    trendTitle: trend.title\n  }\n}));\n\nconsole.log(`âœ… Created ${individualTrends.length} individual trend items for image generation`);\n\nreturn individualTrends;\n"
      },
      "id": "d2323ed2-b825-44f3-8a74-ddd1d43e1787",
      "name": "Split Trends for Image Generation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2064,
        720
      ]
    },
    {
      "parameters": {
        "jsCode": "// Process image URLs directly from LangChain OpenAI node\n// This node should be connected directly to the OpenAI node output, not the debug node\n\nconst inputItems = $input.all();\n\nconsole.log(`ðŸ–¼ï¸ Processing ${inputItems.length} items directly from OpenAI node`);\n\n// Extract image URLs directly from the OpenAI node results\nconst imageUrls = [];\ninputItems.forEach((item, index) => {\n  console.log(`\\nðŸ“‹ Processing item ${index + 1}:`);\n  console.log(`Type: ${typeof item.json}`);\n  console.log(`Keys: ${Object.keys(item.json || {}).join(', ')}`);\n  \n  let imageUrl = null;\n  \n  // The LangChain node with \"Respond with Image URL(s)\" should return URLs directly\n  if (typeof item.json === 'string' && item.json.startsWith('http')) {\n    imageUrl = item.json;\n    console.log(`âœ… Found direct URL: ${imageUrl}`);\n  } else if (item.json && item.json.url) {\n    imageUrl = item.json.url;\n    console.log(`âœ… Found URL in url field: ${imageUrl}`);\n  } else if (item.json && item.json.data && item.json.data.url) {\n    imageUrl = item.json.data.url;\n    console.log(`âœ… Found URL in data.url: ${imageUrl}`);\n  } else if (item.json && item.json.result) {\n    imageUrl = item.json.result;\n    console.log(`âœ… Found URL in result: ${imageUrl}`);\n  } else if (item.json && Array.isArray(item.json) && item.json.length > 0) {\n    imageUrl = item.json[0];\n    console.log(`âœ… Found URL in array: ${imageUrl}`);\n  }\n  \n  if (imageUrl) {\n    console.log(`âœ… Image ${index + 1} generated: ${imageUrl}`);\n    imageUrls.push(imageUrl);\n  } else {\n    console.log(`âŒ No URL found for item ${index + 1}`);\n    console.log(`Full item:`, JSON.stringify(item.json, null, 2));\n    imageUrls.push(null);\n  }\n});\n\nconsole.log(`\\nðŸ“Š Extracted ${imageUrls.filter(url => url).length} URLs out of ${imageUrls.length} items`);\n\n// Return the URLs for further processing\nreturn [{\n  json: {\n    imageUrls: imageUrls,\n    successfulUrls: imageUrls.filter(url => url).length,\n    totalItems: imageUrls.length,\n    generatedAt: new Date().toISOString(),\n    message: \"URLs extracted successfully from OpenAI node.\",\n    urls: imageUrls.filter(url => url) // Only the successful URLs\n  }\n}];\n"
      },
      "id": "a08379c8-91a7-425d-9f30-7402bf8a9944",
      "name": "Process Image Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2512,
        720
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://strategic-trends-dashboard-standalo.vercel.app/api/trends",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "generatedAt",
              "value": "={{ $json.generatedAt }}"
            },
            {
              "name": "sourceSummary",
              "value": "={{ $json.sourceSummary }}"
            },
            {
              "name": "trends",
              "value": "={{ $json.trends }}"
            }
          ]
        },
        "options": {
          "allowUnauthorizedCerts": false,
          "timeout": 10000
        }
      },
      "id": "3975233a-7da3-4eb0-b3a0-585bf106240b",
      "name": "Update Live Dashboard",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3184,
        640
      ],
      "continueOnFail": true,
      "notes": "Posts trends data to live Vercel dashboard API - Both 3D dashboard and screens mode will get updated automatically"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 24
            }
          ]
        }
      },
      "id": "7979a0e9-5b5c-485a-ac0d-325c8fca87f6",
      "name": "Daily Intelligence Update",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        320,
        640
      ]
    },
    {
      "parameters": {
        "url": "https://www.campaignlive.co.uk/rss/news",
        "options": {}
      },
      "id": "c63f64e4-38e5-4a4a-9bf7-07fd5449ed4b",
      "name": "campaignlive - news",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        544,
        256
      ]
    },
    {
      "parameters": {
        "url": "https://www.campaignlive.co.uk/rss/latest",
        "options": {}
      },
      "id": "88774575-4f3f-4de5-b93e-9a4b305db9e1",
      "name": "campaignlive - latest",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        544,
        448
      ]
    },
    {
      "parameters": {
        "url": "https://www.adweek.com/feed/",
        "options": {}
      },
      "id": "7b4b751b-2f7c-4b74-bb5c-edf6ba28903f",
      "name": "adweek",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        544,
        640
      ]
    },
    {
      "parameters": {
        "url": "https://www.reddit.com/r/advertising/.rss",
        "options": {}
      },
      "id": "02228f7c-bbc7-4af3-b813-83126a6bec8b",
      "name": "reddit - advertising",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        544,
        832
      ]
    },
    {
      "parameters": {
        "url": "https://www.reddit.com/r/marketing/.rss",
        "options": {}
      },
      "id": "5432e9c4-ff71-4de7-acf5-5d7b6cddd89e",
      "name": "reddit - marketing",
      "type": "n8n-nodes-base.rssFeedRead",
      "typeVersion": 1.2,
      "position": [
        544,
        1024
      ]
    },
    {
      "parameters": {
        "resource": "image",
        "prompt": "={{ $json.trend.imageGenerationPrompt }}",
        "options": {
          "returnImageUrls": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1.8,
      "position": [
        2288,
        720
      ],
      "id": "283948e1-fa7d-4487-b578-313d2e1235e4",
      "name": "Generate an image",
      "credentials": {
        "openAiApi": {
          "id": "EJ4bHf6JFSTiAvix",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Debug node to see exactly what the LangChain OpenAI node returns\n// This will help us understand the data structure\n\nconst inputItems = $input.all();\n\nconsole.log(`ðŸ” Debug: Processing ${inputItems.length} items from OpenAI node`);\n\n// Log each item in detail\ninputItems.forEach((item, index) => {\n  console.log(`\\nðŸ“‹ Item ${index + 1}:`);\n  console.log(`Type: ${typeof item.json}`);\n  console.log(`Keys: ${Object.keys(item.json || {}).join(', ')}`);\n  console.log(`Full JSON:`, JSON.stringify(item.json, null, 2));\n  \n  // Check if it's a string that might be a URL\n  if (typeof item.json === 'string') {\n    console.log(`String content: ${item.json.substring(0, 100)}...`);\n    if (item.json.startsWith('http')) {\n      console.log(`âœ… Found URL: ${item.json}`);\n    }\n  }\n  \n  // Check nested structures\n  if (item.json && typeof item.json === 'object') {\n    if (item.json.data) {\n      console.log(`Data object:`, JSON.stringify(item.json.data, null, 2));\n    }\n    if (item.json.result) {\n      console.log(`Result:`, item.json.result);\n    }\n    if (item.json.url) {\n      console.log(`URL:`, item.json.url);\n    }\n  }\n});\n\n// Try to extract any URLs we can find\nconst foundUrls = [];\ninputItems.forEach((item, index) => {\n  let url = null;\n  \n  // Check all possible locations\n  if (typeof item.json === 'string' && item.json.startsWith('http')) {\n    url = item.json;\n  } else if (item.json && item.json.url) {\n    url = item.json.url;\n  } else if (item.json && item.json.data && item.json.data.url) {\n    url = item.json.data.url;\n  } else if (item.json && item.json.result) {\n    url = item.json.result;\n  } else if (item.json && item.json.imageUrl) {\n    url = item.json.imageUrl;\n  }\n  \n  if (url) {\n    console.log(`âœ… Found URL for item ${index + 1}: ${url}`);\n    foundUrls.push(url);\n  } else {\n    console.log(`âŒ No URL found for item ${index + 1}`);\n    foundUrls.push(null);\n  }\n});\n\nconsole.log(`\\nðŸ“Š Summary: Found ${foundUrls.filter(url => url).length} URLs out of ${foundUrls.length} items`);\n\nreturn [{\n  json: {\n    debug: {\n      totalItems: inputItems.length,\n      foundUrls: foundUrls.filter(url => url).length,\n      urls: foundUrls,\n      message: \"Check console logs for detailed debug information\"\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        1248
      ],
      "id": "394a9b70-b458-439e-a559-1eca53eb9aba",
      "name": "Debug Code"
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2736,
        640
      ],
      "id": "bc9ccd6e-57f8-4deb-8068-00069042c2f8",
      "name": "Merge1"
    },
    {
      "parameters": {
        "jsCode": "const inputItems = $input.all();\n\nconsole.log(`ðŸ” DEBUG MERGE: Processing ${inputItems.length} inputs`);\n\ninputItems.forEach((item, index) => {\n  console.log(`\\nðŸ“‹ Input ${index + 1}:`);\n  console.log(`Type: ${typeof item.json}`);\n  console.log(`Keys: ${Object.keys(item.json || {}).join(', ')}`);\n  \n  if (item.json && item.json.trends) {\n    console.log(`ðŸ“Š Input ${index + 1} has ${item.json.trends.length} trends`);\n    console.log(`First trend:`, item.json.trends[0]);\n  }\n  \n  if (item.json && item.json.imageUrls) {\n    console.log(`ðŸ–¼ï¸ Input ${index + 1} has ${item.json.imageUrls.length} image URLs`);\n    console.log(`First URL:`, item.json.imageUrls[0]);\n  }\n  \n  if (item.json && item.json.urls) {\n    console.log(`ðŸ–¼ï¸ Input ${index + 1} has ${item.json.urls.length} URLs`);\n    console.log(`First URL:`, item.json.urls[0]);\n  }\n  \n  if (typeof item.json === 'string' && item.json.startsWith('http')) {\n    console.log(`ðŸ–¼ï¸ Input ${index + 1} is a direct URL:`, item.json);\n  }\n});\n\nlet originalTrends = [];\nlet imageUrls = [];\n\ninputItems.forEach((item, index) => {\n  if (item.json && item.json.trends) {\n    originalTrends = item.json.trends;\n  }\n  \n  if (item.json && item.json.imageUrls) {\n    imageUrls = item.json.imageUrls;\n  } else if (item.json && item.json.urls) {\n    imageUrls = item.json.urls;\n  }\n  \n  if (typeof item.json === 'string' && item.json.startsWith('http')) {\n    imageUrls.push(item.json);\n  }\n});\n\nconsole.log(`\\nðŸ“Š FINAL SUMMARY:`);\nconsole.log(`- Original trends: ${originalTrends.length}`);\nconsole.log(`- Image URLs: ${imageUrls.filter(url => url).length}`);\nconsole.log(`- Image URLs array:`, imageUrls);\n\nconst processedTrends = originalTrends.map((trend, index) => {\n  const imageUrl = imageUrls[index] || null;\n  \n  if (imageUrl) {\n    console.log(`ðŸŽ¯ Assigned image to \"${trend.title}\": ${imageUrl}`);\n  } else {\n    console.log(`âŒ No image for \"${trend.title}\" (index ${index})`);\n  }\n  \n  return {\n    ...trend,\n    creative: {\n      ...trend.creative,\n      imageUrl: imageUrl\n    }\n  };\n});\n\nconst successfulImages = processedTrends.filter(t => t.creative.imageUrl).length;\nconsole.log(`âœ… Successfully assigned ${successfulImages} images to trends`);\n\nreturn [{\n  json: {\n    trends: processedTrends,\n    generatedAt: new Date().toISOString(),\n    sourceSummary: {\n      totalFetched: processedTrends.length,\n      afterCluster: processedTrends.length,\n      sources: ['Strategic Market Intelligence']\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2960,
        640
      ],
      "id": "8eb2d0c1-041c-4d18-972a-b934cc5c6a00",
      "name": "Code"
    }
  ],
  "pinData": {},
  "connections": {
    "Merge RSS Sources": {
      "main": [
        [
          {
            "node": "Process Articles",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Articles": {
      "main": [
        [
          {
            "node": "Strategic Trend Analyzer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Strategic Trend Analyzer",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Strategic Trend Analyzer",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Strategic Trend Analyzer": {
      "main": [
        [
          {
            "node": "Finalize Trends",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Finalize Trends": {
      "main": [
        [
          {
            "node": "Generate Image Prompts",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Image Prompts": {
      "main": [
        [
          {
            "node": "Split Trends for Image Generation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Trends for Image Generation": {
      "main": [
        [
          {
            "node": "Generate an image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Image Results": {
      "main": [
        [
          {
            "node": "Merge1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Daily Intelligence Update": {
      "main": [
        [
          {
            "node": "campaignlive - news",
            "type": "main",
            "index": 0
          },
          {
            "node": "campaignlive - latest",
            "type": "main",
            "index": 0
          },
          {
            "node": "adweek",
            "type": "main",
            "index": 0
          },
          {
            "node": "reddit - advertising",
            "type": "main",
            "index": 0
          },
          {
            "node": "reddit - marketing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "campaignlive - news": {
      "main": [
        [
          {
            "node": "Merge RSS Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "adweek": {
      "main": [
        [
          {
            "node": "Merge RSS Sources",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "campaignlive - latest": {
      "main": [
        [
          {
            "node": "Merge RSS Sources",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "reddit - advertising": {
      "main": [
        [
          {
            "node": "Merge RSS Sources",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "reddit - marketing": {
      "main": [
        [
          {
            "node": "Merge RSS Sources",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Generate an image": {
      "main": [
        [
          {
            "node": "Process Image Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Code": {
      "main": [
        []
      ]
    },
    "Merge1": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Update Live Dashboard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "26a6217d-822e-465d-96be-ed6acbe37f7f",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "35da76c3eaa1cbc2ecc4af2ce11b5301cbd1d6edd58a285384cc9e60d637dd8b"
  },
  "id": "LG3cXZGowLL0SIEK",
  "tags": []
}